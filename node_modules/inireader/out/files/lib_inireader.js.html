<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib&#x2F;inireader.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/IniReader.html">IniReader</a></li>
            
                <li><a href="..&#x2F;classes/IniReaderCore.html">IniReaderCore</a></li>
            
                <li><a href="..&#x2F;classes/IniReaderInheritDefault.html">IniReaderInheritDefault</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/IniReader.html">IniReader</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib&#x2F;inireader.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*jslint node: true, sloppy: true, es5: true *&#x2F;
&#x2F;&#x2F; regular expressions to clear, validate and get the values
&#x2F;*jslint regexp: true *&#x2F;
&#x2F;**
 * Regular expression to find lines which shouldn&#x27;t be parsed
 * @property skipLineRex
 * @final
 * @private
 *&#x2F;
var skipLineRex = &#x2F;^\s*(\n|\#|;)&#x2F;,
    &#x2F;**
     * Regular expression to remove white space chars from the beginning and end of
     * a line
     * @property chompRex
     * @final
     * @private
     *&#x2F;
    chompRex = &#x2F;(?:\n|\r)$&#x2F;,
    &#x2F;**
     * Regular expression to find non whitespace characters
     * @property nonWhitespaceRex
     * @final
     * @private
     *&#x2F;
    nonWhitespaceRex = &#x2F;\S&#x2F;,
    &#x2F;**
     * Regular expression to find key&#x2F;value pairs in a line
     * @property keyValueRex
     * @final
     * @private
     *&#x2F;
    keyValueRex = &#x2F;^\s*([^=]*\w)\s*=\s*(.*)\s*$&#x2F;,
    &#x2F;**
     * Regular expression to find group entry marker in an ini file
     * @property groupRex
     * @final
     * @private
     *&#x2F;
    groupRex = &#x2F;^\s*\[\s*([^\]]+)\s*\]$&#x2F;,
    &#x2F;**
     * @property interPolationRexG
     * @final
     * @private
     *&#x2F;
    interPolationRexG = &#x2F;%\(.*?\)&#x2F;g,
    &#x2F;**
     * @property interPolationRex
     * @final
     * @private
     *&#x2F;
    interPolationRex = &#x2F;%\((.*?)\)&#x2F;;

&#x2F;*jslint regexp: false*&#x2F;

&#x2F;**
 * Reads a file and returns it&#x27;s lines as an array
 * @method getLines
 * @param {String} file File name to load and parse
 * @param {Function} cb Callback function to call when parse finished
 * @param {Boolean} async Use synchronous or asynchronous file operations
 * @private
 * @return {Array} Lines of the file
 *&#x2F;
var getLines = function (file, cb, async) {
    var fs = require(&#x27;fs&#x27;), splitLines, data;
    splitLines = function (data) {
        data = data.toString();
        var lines;
        if (data.indexOf(&#x27;\r\n&#x27;) &gt; -1) {
            lines = data.split(&#x27;\r\n&#x27;);
        } else if (data.indexOf(&#x27;\n&#x27;) &gt; -1) {
            lines = data.split(&#x27;\n&#x27;);
        } else if (data.indexOf(&#x27;\r&#x27;) &gt; -1) {
            lines = data.split(&#x27;\r&#x27;);
        } else { &#x2F;&#x2F; mostly it&#x27;s only one line
            lines = [data];
        }
        return lines.filter(function emptyLineFilter(line) {
            return line !== &#x27;&#x27;;
        });
    };
    if (async) {
        fs.readFile(file, function fileReadCb(err, data) {
            if (err) {
                throw err;
            }
            cb(splitLines(data));
        });
    } else {
        data = fs.readFileSync(file);
        return splitLines(data);
    }
};

&#x2F;**
 * If a string is inside quotes, the quotes will be removed It doesn&#x27;t care
 * about escaped&#x2F;not escaped strings. So you can have thing like this:
 * &quot;lorem ipsum&quot; dolor sit&quot;
 * and you will receive:
 * lorem ipsum&quot; dolor sit
 * @method fixQuoted
 * @param {String} str
 * @return {String} String without starting and closing quotes
 * @private
 *&#x2F;
var fixQuoted = function (str) {
    if (
        (str[0] === &#x27;&quot;&#x27; &amp;&amp; str[str.length - 1] === &#x27;&quot;&#x27;) ||
            (str[0] === &quot;&#x27;&quot; &amp;&amp; str[str.length - 1] === &quot;&#x27;&quot;)
    ) {
        return str.substr(1, str.length - 2);
    }
    return str;
};

&#x2F;**
 * Return a deep copy of the object
 * @method deepCopy
 * @param {Object} sourceObj The object which should be copied
 * @param {Object} [destinationObj] The destination object which should have
 * the new properties after copy
 * @return {Object} Object with the new parameters
 * @private
 *&#x2F;
var deepCopy = function (sourceObj, destinationObj) {
    var out = destinationObj || {}, key;
    Object.keys(sourceObj).forEach(function (key) {
        if (typeof sourceObj[key] === &#x27;object&#x27;) {
            out[key] = (sourceObj[key].constructor === Array ? [] : {});
            deepCopy(sourceObj[key], out[key]);
        } else {
            out[key] = sourceObj[key];
        }
    });

    return out;
};

&#x2F;**
 * Parses a .ini file and convert&#x27;s it&#x27;s content to a JS object
 * Parser regexps are from the Config::Simple Perl module
 * @class IniReaderCore
 * @constructor
 * @module IniReader
 * @main IniReader
 * @extends EventEmitter
 * @param {Object} [cfg] Configuration object. (In older versions it could be a
 * string too, which was the file name to parse, but that behaviour is
 * deprectaed)
 *     @param {Boolean} [cfg.async] If true, it will use asynchronous calls to
 *     read and write files
 *     @param {String} [cfg.file] The file name to read or write during
 *     operations
 * @param {Boolean} [async] (Deprecated) Use the cfg.async instead.
 *&#x2F;
function IniReaderCore(cfg, async) {
    this.construct(cfg, async);
}
require(&#x27;util&#x27;).inherits(IniReaderCore, require(&#x27;events&#x27;).EventEmitter);
&#x2F;**
 * Name of the file.
 * Doing a load method and without specifying it&#x27;s name directly that property
 * will be used.
 * Doing a write method and without specifying it&#x27;s name directly that property
 * will be used.
 * @property file
 * @type {String}
 * @default null
 *&#x2F;
&#x2F;**
 * If true all file operation will be done asynchronously
 * @property async
 * @type {Boolean}
 * @default false
 *&#x2F;
&#x2F;**
 * Error event emitted every time an error occured
 * @event error
 *&#x2F;
&#x2F;**
 * Event emitted when a file parse finished
 * @event fileParse
 *&#x2F;
&#x2F;**
 * Event emitted when the configuration has been written to a file
 * @event fileWritten
 *&#x2F;
&#x2F;**
 * Initializes the configuration properties
 * @method construct
 * @param {Object} [cfg] Configuration object. (In older versions it could be a
 * string too, which was the file name to parse, but that behaviour is
 * deprectaed)
 *     @param {Boolean} [cfg.async] If true, it will use asynchronous calls to
 *     read and write files
 *     @param {String} [cfg.file] The file name to read or write during
 *     operations
 * @param {Boolean} [async] (Deprecated) Use the cfg.async instead.
 * @constructor
 *&#x2F;
IniReaderCore.prototype.construct = function (cfg, async) {
    &#x2F;&#x2F; backward compatibility
    &#x2F;&#x2F; in first versions the first argument was the file name and the second was
    &#x2F;&#x2F; the async flag
    if (typeof cfg === &#x27;string&#x27;) {
        cfg = {
            file: cfg
        };
        if (async === &#x27;boolean&#x27;) {
            cfg.async = async;
        }
    }
    cfg = cfg || {};
    this.async = !!cfg.async;
    this.file = cfg.file || null;
};
&#x2F;**
 * Loads a ini file
 * @method load
 * @param String file
 **&#x2F;
IniReaderCore.prototype.load = IniReaderCore.prototype.init = function load(file) {
    if (typeof file === &#x27;string&#x27;) {
        this.file = file;
    }
    if (!this.file) {
        this.emit(&#x27;error&#x27;, new Error(&#x27;No file name given&#x27;));
    }
    try {
        if (this.async) {
            getLines(this.file, function parseLines(lines) {
                this.lines = lines;
                this.values = this.parseFile();
                this.emit(&#x27;fileParse&#x27;);
            }.bind(this), true);
        } else {
            this.lines = getLines(this.file);
            this.values = this.parseFile();
            this.emit(&#x27;fileParse&#x27;);
        }
    } catch (e) {
        this.emit(&#x27;error&#x27;, e);
    }
};

&#x2F;**
  * Tries to find a group name in a line
  * @method parseSectionHead
  * @type {String|False}
  * @return {String | False} the group name if found or false
  *&#x2F;
IniReaderCore.prototype.parseSectionHead = function parseSectionHead(line) {
    var groupMatch = line.match(groupRex);
    return groupMatch ? groupMatch[1] : false;
};

&#x2F;**
  * Tries to find a key&#x2F;value pair in a line
  * @method keyValueMatch
  * @type {Object|False}
  * @return {Object | False} the key value pair in an object ({key: &#x27;key&#x27;,
  * value;&#x27;value&#x27;}) if found or false
  *&#x2F;
IniReaderCore.prototype.keyValueMatch = function keyValMatch(line) {
    var kvMatch = line.match(keyValueRex);
    return kvMatch ? {key: kvMatch[1], value: kvMatch[2]} : false;
};

&#x2F;**
  * Parses an init file, and extracts blocks with keys and values
  * @method parseFile
  * @return {Object} The configuration tree
  *&#x2F;
IniReaderCore.prototype.parseFile = function parseFile() {

    var output, lines, groupName, keyVal, line, currentSection, lineNumber;

    output = {};
    lines = this.lines;

    lineNumber = 0;

    while (lines.length) {
        line = lines.shift();

        lineNumber += 1;
        &#x2F;&#x2F; skip comments and empty lines
        if (!skipLineRex.test(line) &amp;&amp; nonWhitespaceRex.test(line)) {
            line = line.replace(chompRex, &#x27;&#x27;);
            line = line.trim();

            &#x2F;&#x2F; block name
            groupName = this.parseSectionHead(line);
            if (groupName) {
                currentSection = groupName;
                if (!output[currentSection]) {
                    output[currentSection] = {};
                }
            } else {
                &#x2F;&#x2F; key&#x2F;value pairs
                keyVal = this.keyValueMatch(line);
                if (keyVal) {
                    if (currentSection) {
                        output[currentSection][keyVal.key] = fixQuoted(keyVal.value);
                    } else {
                        &#x2F;&#x2F; outside of a section
                        this.emit(&#x27;error&#x27;, new SyntaxError(&quot;Syntax error in line &quot; + lineNumber));
                    }
                } else {
                    &#x2F;&#x2F; keyVal not found and not commented so something is wrong
                    this.emit(&#x27;error&#x27;, new SyntaxError(&quot;Syntax error in line &quot; + lineNumber));
                }
            }
        }

    }

    return output;
};
&#x2F;**
 * Method to get a one property value or a ini block or all of the block of
 * the loaded configuration
 * @method getBlock
 * @return {String | Number | Object | Null | Boolean | Undefiend} The property
 * value
 * @type Object
 * @deprecated
 *&#x2F;
IniReaderCore.prototype.getBlock = function getBlock(block) {
    return this.param(block);
};
&#x2F;**
  * @method getValue
  * @param String block The name of the block where the key should be defined
  * @param String key The name of the key which value should be returned
  * @return {String | Number | Object | Null | Boolean | Undefiend} the value of the key
  * @deprecated
  *&#x2F;
IniReaderCore.prototype.getValue = function getValue(block, key) {
    var param = block;
    if (typeof key !== &#x27;undefined&#x27;) {
        param += &#x27;.&#x27; + key;
    }
    return this.getParam(param);
};

&#x2F;**
 * Method to get the configuration tree or a configuration block a specific
 * value in a block.
 * @method getParam
 * @param {String} [param] The name of the block where the key should be
 * defined. You can get the whole configuration tree by not setting this
 * argument.
 * You can get a configuration block by passing its name: getParam(&#x27;fooblock&#x27;).
 * You can get a specific property by passing its block name with the property
 * name. They should be concatenated with a &quot;.&quot;:
 * getParam(&#x27;fooblock.barproperty&#x27;).
 * @return {String | Number | Object | Null | Boolean | Undefiend} The property
 * value
 *&#x2F;
IniReaderCore.prototype.getParam = function getParam(param) {
    var output = this.values,
        block,
        key;

    if (param) {
        param = param.split(&#x27;.&#x27;);
        block = param[0];
        key = param[1];

        if (block) {
            output = output[block];

            if (key) {
                output = output[key];
            }
        }
    }

    return output;
};
&#x2F;**
 * Sets the parameter in the loaded configuration object.
 * @method setParam
 * @param {String} prop The name of the property which should be set
 * @param {String | Number | Object | Null | Boolean} value The new value of the property
 *&#x2F;
IniReaderCore.prototype.setParam = function setParam(prop, value) {
    if (typeof this.values !== &#x27;object&#x27;) {
        this.values = {};
    }
    var propKeys = prop.split(&#x27;.&#x27;),
        propKeysLen = propKeys.length,
        ref = this.values;
    if (propKeysLen &gt; 0) {
        propKeys.forEach(function propKeyParser(key, index) {
            if (!ref[key]) {
                ref[key] = {};
            }
            if (index &lt; propKeysLen - 1) {
                ref = ref[key];
            } else {
                ref[key] = value;
            }
        }, this);
    }
};
&#x2F;**
 * Setter and getter method. If only the first parameter defined it will return
 * the value of the parameter. If the second parameter set, it will set the
 * parameter in the loaded configuration object.
 * @method param
 * @param {String} prop The name of the property which should be returned or
 * which should be set
 * @param {String | Number | Object | Null | Boolean} value The new value of the property
 * @return {String | Number | Object | Null | Boolean | Undefiend} The property
 * value if the method was called with one argument or undefined if it was
 * called with two arguments
 *&#x2F;
IniReaderCore.prototype.param = function param(prop, value) {
    var output;
    if (typeof value === &#x27;undefined&#x27;) {
        output = this.getParam(prop);
    } else {
        output = this.setParam(prop, value);
    }
    return output;
};

&#x2F;**
 * @method getLe
 * @param {String} [le] Predefined line ending character. Only &quot;\n&quot;, &quot;\r&quot; and
 * &quot;\r\n&quot; are valid values!
 * @return {String} The line ending character or characters. Default is &quot;\n&quot;
 *&#x2F;
IniReaderCore.prototype.getLe = function getLe(le) {
    return typeof le === &#x27;string&#x27; &amp;&amp; (le === &#x27;\n&#x27; || le === &#x27;\r\n&#x27; || le === &#x27;\r&#x27;) ? le : &#x27;\n&#x27;;
};

&#x2F;**
 * Converts the currently loaded configuration to a INI file.
 * @method serialize
 * @param {String} [le] Predefined line ending character
 * @return {String} Currently loaded configuration as a INI file content which
 * could be written directly into a file
 *&#x2F;
IniReaderCore.prototype.serialize = function serialize(le) {
    var output = &#x27;&#x27;,
        ws = &#x2F;\s+&#x2F;,
        values = this.values,
        group;

    le = this.getLe(le);

    Object.keys(values).forEach(function serializeGroup(group) {
        output += le + &#x27;[&#x27; + group + &#x27;]&#x27; + le;
        var groupValues = values[group];

        Object.keys(groupValues).forEach(function serializeKey(key) {
            var value = groupValues[key];
            if (ws.test(value)) {
                if (value.indexOf(&#x27;&quot;&#x27;) &gt; -1) {
                    value = &quot;&#x27;&quot; + value + &quot;&#x27;&quot;;
                } else {
                    value = &#x27;&quot;&#x27; + value + &#x27;&quot;&#x27;;
                }
            }
            output += key + &#x27;=&#x27; + value + le;
        }, this);
    }, this);

    return output;
};

&#x2F;**
 * Write ini file to the disk
 * @method write
 * @param {String} [file] File name
 * @param {String} [le] Line ending string
 *&#x2F;
IniReaderCore.prototype.write = function (file, le) {
    if (!file) {
        file = this.file;
    }

    &#x2F;&#x2F; get last line
    le = this.getLe(le);

    var now = new Date(),
      &#x2F;&#x2F; create a headline
        output = &#x27;; IniReader&#x27; + le + &#x27;; &#x27; + now.getFullYear() + &#x27;-&#x27; +
            (now.getMonth() + 1) + &#x27;-&#x27; + now.getDate() + le,
        ws = &#x2F;\s+&#x2F;,
        fs = require(&#x27;fs&#x27;),
        group,
        item,
        value;

    output += this.serialize(le);

    if (this.async) {
        fs.writeFile(file, output, function writeFile(err) {
            if (err) {
                this.emit(&#x27;error&#x27;, err);
            }
            this.emit(&#x27;fileWritten&#x27;, file);
        }.bind(this));
    } else {
        fs.writeFileSync(file, output);
        this.emit(&#x27;fileWritten&#x27;, file);
    }
};

&#x2F;**
 * @method interpolate
 * @param {String} param
 * @return {Object}
 *&#x2F;
IniReaderCore.prototype.interpolate = function (param) {
    var output = this.getParam(param),
        self = this,
        block,
        key,
        refParams,
        refParam,
        references,
        sBlock,
        sKey;

    if (typeof output !== &#x27;undefined&#x27;) {
        if (typeof output === &#x27;object&#x27;) {
            output = deepCopy(output);
        }
        if (param) {
            param = param.split(&#x27;.&#x27;);
            block = param[0];
            key = param[1];
        }

        &#x2F;&#x2F; no argument given
        if (typeof block === &#x27;undefined&#x27;) {
            Object.keys(output).forEach(function (sBlock) {
                Object.keys(output[sBlock]).forEach(function (sKey) {
                    output[sBlock][sKey] = self.interpolate(sBlock + &#x27;.&#x27; + sKey);
                });
            });
        &#x2F;&#x2F; argument is block or block.key
        } else {
            &#x2F;&#x2F; argument is block
            if (typeof key === &#x27;undefined&#x27;) {
                Object.keys(output).forEach(function (sKey) {
                    output[sKey] = self.interpolate(block + &#x27;.&#x27; + sKey);
                });
            &#x2F;&#x2F; argument is block.key
            } else {
                if (typeof output === &#x27;string&#x27;) {
                    references = output.match(interPolationRexG);
                    if (references) {
                        references.forEach(function (reference) {
                            var refKey = reference.replace(interPolationRex, &#x27;$1&#x27;);
                            refParams = refKey.split(&#x27;.&#x27;);
                            &#x2F;&#x2F; interpolation in current block
                            if (refParams.length &lt; 2) {
                                refParam = block + &#x27;.&#x27; + refParams[0];
                            } else {
                                refParam = refKey;
                            }
                            output = output.replace(reference, self.interpolate(refParam));
                        });
                    }
                }
            }
        }
    }
    return output;
};

exports.IniReaderCore = IniReaderCore;


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
